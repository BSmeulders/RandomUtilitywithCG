function [Aout, fprice] = RUMX_55_PriceHeurBI(X, priceobj, target)
% We first compute how many patches there are on each budget.
Nr_Patch = zeros(size(X,2),1);
first_patch = ones(size(X,2), 1);
for ii = 1:size(X,2)
    Nr_Patch(ii,1) = size(find(X(:,ii) == 0),1);
    first_patch(ii+1, 1) = first_patch(ii, 1) + Nr_Patch(ii, 1);
end

% First, create random permutations of the budgets, which will determine in
% which order the bugets are added in the best insertion.
InsertOrders = zeros(10, size(X,2));
for ii = 1:10
    InsertOrders(ii,:) = randperm(size(X,2));
end

fprice = -99;
Aout = zeros(1,size(X,1));
for ii = 1:10 % One loop for each insertion order.
    IncumbentOrder = zeros(size(X,2),1);
    IncumbentOrder(1) = InsertOrders(ii, 1);
    IncumbentPatches = zeros(size(X,2),1);
    Currentlength = 1;
    IncumbentOrderIndValue = zeros(size(X,2), 1); % The value each individual budget adds to the current order.
    [IncumbentOrderIndValue(1),IncumbentPatches(1)] = max(priceobj(first_patch(IncumbentOrder(1)):first_patch(IncumbentOrder(1))+Nr_Patch(IncumbentOrder(1))-1));
    IncumbentPatches(1) = IncumbentPatches(1) + first_patch(IncumbentOrder(1))-1;
    while Currentlength < size(X,2) % This loop goes until all budgets have been added.
            TempLocationValue = ones(size(X,2), 1)*-99; % This saves the total value of adding a budget at a particular location.
            TempOrderIndValue = zeros(size(X,2), Currentlength + 1); % Saves the value of each individual budget for the given insertion location.
            TempPatches = zeros(size(X,2), Currentlength + 1); % Saves the best patch for each individual budget for the given insertion location.
        for InsertLocation = 1:Currentlength + 1 % Check each position for insertion
            % Position jj means that every budget currently placed at jj or further back is pushed back one position. (The inserted budget would be at position jj).
            for kk = 1:Currentlength +1  % Check the value generated by each location
                TempMaxPatchValue = -99;
                if kk > InsertLocation % No new constraints on budgets behind the insertion point. The individual contribution thus stays the same. 
                    TempOrderIndValue(kk, InsertLocation) = IncumbentOrderIndValue(kk-1);
                    TempPatches(kk, InsertLocation) = IncumbentPatches(kk-1);
                elseif kk == InsertLocation 
                    for patches = first_patch(InsertOrders(ii,Currentlength+1)):first_patch(InsertOrders(ii,Currentlength+1))+Nr_Patch(InsertOrders(ii,Currentlength+1))-1
                        if priceobj(patches) > TempMaxPatchValue % Only evaluate the feasibility, if it is a better patch than the incumbent.
                            feasible = 1;
                            for ll = InsertLocation:Currentlength
                                if X(patches, IncumbentOrder(ll)) == -1
                                    feasible = 0;
                                    break;
                                end
                            end
                            if feasible == 1 && priceobj(patches) > TempMaxPatchValue
                                TempMaxPatchValue = priceobj(patches);
                                TempPatches(InsertLocation, kk) = patches;
                            end
                        end
                    end
                    TempOrderIndValue(kk, InsertLocation) = TempMaxPatchValue;
                else
                    for patches = first_patch(IncumbentOrder(kk)):first_patch(IncumbentOrder(kk))+Nr_Patch(IncumbentOrder(kk))-1
                        if priceobj(patches) > TempMaxPatchValue % Only evaluate the feasibility, if it is a better patch than the incumbent.
                            feasible = 1;
                            for ll = kk:Currentlength
                                if X(patches, IncumbentOrder(ll)) == -1
                                    feasible = 0;
                                    break;
                                end
                            end
                            if X(patches, InsertOrders(ii, Currentlength + 1)) == -1
                                    feasible = 0;
                            end
                            if feasible == 1 && priceobj(patches) > TempMaxPatchValue
                                TempMaxPatchValue = priceobj(patches);
                                TempPatches(kk,InsertLocation ) = patches;
                            end
                        end
                    end
                    TempOrderIndValue(kk, InsertLocation) = TempMaxPatchValue;
                end  
            end
            TempLocationValue(InsertLocation) = sum(TempOrderIndValue(:,InsertLocation));
        end
        % Find the best location for insertion.
        [IncumbentOrderValue,BestLocation] = max(TempLocationValue(1:Currentlength+1));
        IncumbentOrder(BestLocation+1:Currentlength+1) = IncumbentOrder(BestLocation:Currentlength);
        IncumbentOrder(BestLocation) = InsertOrders(ii, Currentlength + 1);
        IncumbentPatches = TempPatches(:,BestLocation);
        IncumbentOrderIndValue = TempOrderIndValue(:,BestLocation);
        Currentlength = Currentlength + 1;
    end
    % The order has been made, now we translate it to a a column for the QP
    % problem.
    AoutTemp = zeros(size(X,1), 1);
    for jj = 1:size(X,2)
        AoutTemp(IncumbentPatches(jj)) = 1;
    end
    % Chech whether it improves on the current incumbent Aout. 
    fpriceTemp = AoutTemp'*priceobj;
    if fpriceTemp > fprice
        fprice = fpriceTemp;
        Aout = AoutTemp;
    end
    %if fpriceTemp > target && size(Aout, 1) > 1
    %    Aout = [Aout AoutTemp];
    %else if fpriceTemp > target && size(Aout, 1) == 1
    %        Aout = AoutTemp;
    %end
end


end